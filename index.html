<html>
<head>
	<script>
		//implement inertia and gradual slowening of current movementxy
		//implement "isGrounded flag" for player
		//implementing jump for player
		//try to use current setup to make jumps
		var ready = false;
		var canvas = null;
		var ctx = null;
		var sprites = [];
		var gravityInPixelsPerSecond = 100;
		var worldWidth = 400;
		var worldHeight = 200;
		var player = null;
		var parameters = {
			playerFriction: 0.9,
			playerAcceleration: 0.3,
			playerTopSpeed: 3.0
		};

		window.requestAnimFrame = (function(){
		  return  window.requestAnimationFrame       ||
		          window.webkitRequestAnimationFrame ||
		          window.mozRequestAnimationFrame    ||
		          function( callback ){
		            window.setTimeout(callback, 1000 / 60);
		          };
		})();

		function initialize() {
			updateParameters();
			bindInputs();

			canvas = document.getElementById('tutorial');
			ctx = canvas.getContext('2d');
			ready = true;

			player = {
				type: 'circle',
				x: 200,
				y: 0,
				radius: 5,
				color: 'yellow',
				gravity: true,
				xMovement: 0.0,
				yMovement: 0.0
			};
			sprites.push(player);
			sprites.push({
				type: 'rectangle',
				x: 100,
				y: 100,
				width: 20,
				height: 20,
				color: '#FF0000',
				gravity: true,
				xMovement: 0.0,
				yMovement: 0.0
			});
			sprites.push({
				type: 'circle',
				x: 0,
				y: 100,
				radius: 20,
				color: '#00FF00',
				gravity: true,
				xMovement: 0.0,
				yMovement: 0.0
			});
			sprites.push({
				type: 'rectangle',
				x: 300,
				y: 0,
				width: 20,
				height: 20,
				color: 'yellow',
				gravity: true,
				xMovement: 0.0,
				yMovement: 0.0
			});

			sprites.push({
				type: 'rectangle',
				x: 300,
				y: 100,
				width: 20,
				height: 20,
				color: 'yellow',
				gravity: true,
				xMovement: 0.0,
				yMovement: 0.0
			});
			animateWorld();
		}

		function onAnimationFrame() {
			if (!ready) {
				return;
			}

			ctx.fillStyle = "#DDDDDD";
			ctx.fillRect(0, 0, worldWidth, worldHeight);

			for (var i = 0; i < sprites.length; i++) {
				var sprite = sprites[i];
				if (sprite.type === 'rectangle') {
					ctx.fillStyle = sprite.color;
					ctx.fillRect(sprite.x, 
						sprite.y,
						sprite.width,
						sprite.height);
				}
				else if (sprite.type === 'circle') {
					ctx.beginPath();
				    ctx.arc(sprite.x, sprite.y, sprite.radius, 0, 2 * Math.PI, false);
				    ctx.fillStyle = sprite.color;
				    ctx.fill();
				    ctx.lineWidth = 5;
				    ctx.strokeStyle = sprite.color;
				    ctx.stroke();
				}
			}
			
		}

		function collisionCircles(circleA, circleB) {
			var distanceX = circleA.x - circleB.x;
			var distanceY = circleA.y - circleB.y;
			var radiusSum = circleA.radius + circleB.radius;

			distanceX = distanceX * distanceX;
			distanceY = distanceY * distanceY;
			radiusSum = radiusSum * radiusSum;

			return distanceX + distanceY < radiusSum;
		}

		function collisionRectangles(r1, r2) {
		  return !(r2.x > r1.x + r1.width || 
		           r2.x + r2.width < r1.x || 
		           r2.y > r1.y + r1.height ||
		           r2.y + r2.height< r1.y);
		}

		function collisionCircleToRectangle(circle,rect){
		    var distX = Math.abs(circle.x - rect.x-rect.width/2);
		    var distY = Math.abs(circle.y - rect.y-rect.height/2);

		    if (distX > (rect.width/2 + circle.radius)) { return false; }
		    if (distY > (rect.height/2 + circle.radius)) { return false; }

		    if (distX <= (rect.width/2)) { return true; } 
		    if (distY <= (rect.height/2)) { return true; }

		    var dx=distX-rect.width/2;
		    var dy=distY-rect.height/2;
		    return (dx*dx+dy*dy<=(circle.radius * circle.radius));
		}

		function collisionCircleToRectangleOld(circle, rectangle) {
			if (circle.x < rectangle.x + rectangle.width &&
				circle.x > rectangle.x &&
				circle.y < rectangle.y + rectangle.height &&
				circle.y > rectangle.y) {
				return true;
			}
			var vertexes = [{
				x: rectangle.x,
				y: rectangle.y
			}, {
				x: rectangle.x + rectangle.width,
				y: rectangle.y
			}, {
				x: rectangle.x,
				y: rectangle.y + rectangle.height
			}, {
				x: rectangle.x + rectangle.width,
				y: rectangle.y + rectangle.height
			}];

			for (var i = 0; i < vertexes; i++) {
				var vertex = vertexes[i];
				var distanceX = vertex.x - circle.x;
				var distanceY = vertex.y - circle.y;
				var radiusSum = circle.radius;

				distanceX = distanceX * distanceX;
				distanceY = distanceY * distanceY;
				radiusSum = radiusSum * radiusSum;

				if (distanceX + distanceY < radiusSum)
				{
					return true;
				}

			}

		}

		function animateWorld() {
			var interval = 10;
			window.setInterval(function () {
				for (var i = 0; i < sprites.length; i++) {
					var sprite = sprites[i];
					var pixelsToMoveY = sprite.yMovement;
					var pixelsToMoveX = sprite.xMovement;
					var initialX = sprite.x;
					var initialY = sprite.y;

					//should decrease exponentially and depending
					//on collision..
					sprite.xMovement = sprite.xMovement > 0.01 ? sprite.xMovement * parameters.playerFriction : 
									   sprite.xMovement < -0.01 ? sprite.xMovement * parameters.playerFriction : 0.0;
					sprite.yMovement = 0.0;

					if (sprite.gravity) {
						pixelsToMoveY = pixelsToMoveY + gravityInPixelsPerSecond * interval / 1000;
					}
					if (pixelsToMoveY === 0 && pixelsToMoveX === 0)
					{
						continue;
					}

					sprite.y = sprite.y + pixelsToMoveY;
					sprite.x = sprite.x + pixelsToMoveX;

					if (sprite.type === 'rectangle') {
						if (sprite.y + sprite.height > worldHeight)
						{
							sprite.y = worldHeight - sprite.height;
						}
						
						if (sprite.x + sprite.width > worldWidth)
						{
							sprite.x = worldWidth - sprite.width;
						}
					}
					else if (sprite.type === 'circle') {
						if (sprite.y + sprite.radius > worldHeight)
						{
							sprite.y = worldHeight - sprite.radius;
						}
						
						if (sprite.x + sprite.radius > worldWidth)
						{
							sprite.x = worldWidth - sprite.radius;
						}
					}

					var collision = false;
					for (var j = 0; j < sprites.length; j++) {
						if (i === j) {
							continue;
						}
						var spriteToCheck = sprites[j];
						if (sprite.type === 'circle' && 
							spriteToCheck.type === 'circle') {
							if (collisionCircles(sprite, spriteToCheck)) {
								collision = true;
								break;
							}
						}
						else if (sprite.type === 'circle' && 
							spriteToCheck.type === 'rectangle') {
							if (collisionCircleToRectangle(sprite, spriteToCheck)) {
								collision = true;
								break;
							}
						}
						else if (sprite.type === 'rectangle' && 
							spriteToCheck.type === 'circle') {
							if (collisionCircleToRectangle(spriteToCheck, sprite)) {
								collision = true;
								break;
							}
						}
						else if (sprite.type === 'rectangle' && 
							spriteToCheck.type === 'rectangle') {
							if (collisionRectangles(sprite, spriteToCheck)) {
								collision = true;
								break;
							}
						}
					}

					if (collision) {
						sprite.x = initialX;
						sprite.y = initialY;
					}
				}
			}, interval);
		}

		window.onload = initialize;
		window.setInterval(onAnimationFrame, 10);

		document.onkeypress = function (e) {
		    e = e || window.event;
		    //console.log('pressed' + e.keyIdentifier);

		    if (e.keyIdentifier === 'U+0041') {
		    	player.xMovement -= parameters.playerAcceleration;
		    	if (player.xMovement < - parameters.playerTopSpeed) {
		    		player.xMovement = - parameters.playerTopSpeed;
		    	}
		    }
		    else if (e.keyIdentifier === 'U+0044') {
		    	player.xMovement += parameters.playerAcceleration;
		    	if (player.xMovement > parameters.playerTopSpeed) {
		    		player.xMovement = parameters.playerTopSpeed;
		    	}
		    }
		    //console.log('====' + player.xMovement);
		};

		

		function updateParameters() {
			var parameterInputs = document.querySelectorAll('.dynamic-parameter input');

			for (var i = 0; i < parameterInputs.length; i++)
			{
				var parameterInput = parameterInputs[i];
				var value = parameterInput.value;
				var contentType = parameterInput.attributes['content-type'].value;
				var name = parameterInput.attributes['name'].value;

				if (contentType === 'float') {
					parameters[name] = parseFloat(value);
				}

				console.log(parameterInput);
			}
		}

		function bindInputs() {
			var parameterInputs = document.querySelectorAll('.dynamic-parameter input');
			
			for (var i = 0; i < parameterInputs.length; i++)
			{
				parameterInputs[i].addEventListener('change', function () {
					console.log('ciao');
				    updateParameters();
				});
			}
		}

	</script>
</head>
<body>
	<canvas id="tutorial" width="400" height="200"></canvas>
	<div class="dynamic-parameter">PlayerFriction <input name="playerFriction" type="text" value="0.9" content-type="float"/></div>
	<div class="dynamic-parameter">PlayerAcceleration <input name="playerAcceleration" type="text" value="0.3" content-type="float"/></div>
	<div class="dynamic-parameter">PlayerTopSpeed <input name="playerTopSpeed" type="text" value="3.0" content-type="float"/></div>
</body>
</html>
